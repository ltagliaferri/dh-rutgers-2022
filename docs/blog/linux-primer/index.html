<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A Linux Command Line Primer</title>
    <link rel="stylesheet" href="/dh-rutgers-2022/css/style.css" />
  </head>
  <body id="nightModeDiv">
    <nav>
    <p class="logo"><a href="https://ltagliaferri.github.io/dh-rutgers-2022/">Digital Humanities Theories and Practice</a></p>
  
    <div class="nav-list">
      <a href="https://ltagliaferri.github.io/dh-rutgers-2022/about/">Schedule</a>
      <a href="https://ltagliaferri.github.io/dh-rutgers-2022/resources/">Resources</a>
      <!-- <a href="https://ltagliaferri.github.io/dh-rutgers-2022/blog">Blog</a> -->
      <button id="nightModeButton" class="night-mode-btn">
        <svg style="width: 20px;" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" xmlns:xlink="http://www.w3.org/1999/xlink" enable-background="new 0 0 512 512">
          <g>
            <g>
              <path d="m275.4,500.7c-135,0-244.7-109.8-244.7-244.7 1.06581e-14-134.9 109.8-244.7 244.7-244.7 8.2,0 16.4,0.4 24.6,1.2 7.2,0.7 13.5,5.2 16.5,11.7s2.4,14.2-1.6,20.2c-23,33.8-35.2,73.3-35.2,114.2 0,105 78.7,192.2 183.2,202.6 7.2,0.7 13.5,5.2 16.5,11.7 3.1,6.5 2.4,14.2-1.6,20.2-45.8,67.4-121.4,107.6-202.4,107.6zm-12.5-448c-106.5,6.5-191.2,95.2-191.2,203.3 1.42109e-14,112.3 91.4,203.7 203.7,203.7 56.4,0 109.6-23.4 147.8-63.7-46.2-11.7-88.1-36.8-120.8-72.6-41.1-45.2-63.8-103.6-63.8-164.6 0.1-37.1 8.4-73.2 24.3-106.1z"/>
            </g>
          </g>
        </svg>
      </button>
    </div>
  </nav>
  
    <div class="article-wrapper">
      <h1>A Linux Command Line Primer</h1>
      <article class="paragraph text-lg"><p><em>A version of this tutorial was originally published at <a href="https://www.digitalocean.com/community/tutorials/a-linux-command-line-primer">https://www.digitalocean.com/community/tutorials/a-linux-command-line-primer</a>.</em></p>
<h3>Introduction</h3>
<p>Today, many of us are familiar with computers (desktops and laptops), smartphones, and tablets which have graphical user interfaces (also referred to as GUIs), allowing us to navigate apps, the web, and our files (like documents and photos) through a visual experience. The Windows, macOS, and Linux operating systems each present varieties of a desktop environment (with images of folders and files, for example), and dropdown menus, all of which provide access to computer programs, applications, and our own media.</p>
<p>Although GUIs can be an intuitive way to use a computer for many users, they often do not provide us with the greatest power over our machines, and they may prevent us from having full administrative access on our computers, including installing, modifying, or deleting software or files. Additionally, as GUIs are largely visual, they are often not as accessible as they could be for all users.</p>
<p>One way of navigating both your own personal computer and remote cloud servers without a GUI is through a text-based terminal or command-line interface (CLI). Terminal interfaces exist on almost every computer operating system, and terminal emulators are also available as apps for tablets and smartphones. Terminals provide users with greater overall access to their machines through increased administrator access, greater ability to customize environments, and opportunities to automate processes. They also provide users with the ability to access remote computers, such as cloud servers.</p>
<p>This tutorial will provide users who are new to terminal environments with the basics of using a command-line interface through an embedded web terminal in your browser, which you can launch below. If you already have some familiarity with terminals, you may prefer to go through our Introduction to the Linux Terminal tutorial instead. Once you complete this tutorial, you should have an understanding of how to use a terminal on a Linux (or macOS) computer or server.</p>
<h2>Understanding the Terminal Window</h2>
<p>When you first get access to a new computer or smartphone, you likely want to turn it on and get a feel for how to use it by checking which apps are available, and to learn where things are so that you can customize the device to suit your needs. You can become familiar with a computer through a terminal in a similar way.</p>
<p>In many of these Unix (or *nix-based) operating systems, the symbols at the end of the prompt may be a <code>$</code> symbol or a <code>#</code> symbol, which mean the following:</p>
<ul>
<li><code>$</code> or dollar sign — you are logged in as a regular user</li>
<li><code>#</code> or hashtag/pound symbol — you are logged in as a user with elevated privileges</li>
</ul>
<p>The user that is noted in the # environment is also known as a root user, which is considered to be a super user, or administrator, by default.</p>
<p>For our purposes within the browser terminal below, you are logged in as a regular user, but you also have administrator privileges via the sudo command. As this is a temporary terminal, you do not need to worry about what you type into the terminal, as we will destroy everything once we are done. Similarly, with a cloud server, it is possible to destroy a server and start fresh if something goes awry.</p>
<blockquote>
<p><strong>Please note</strong> that it is best to exercise more care when working on a local computer’s terminal as there may be changes you can make as an administrator on the terminal that can make permanent changes on the computer you are using.</p>
</blockquote>
<p>At this point, with your terminal launched in the browser, you can begin to type into it using your local computer. Your text will appear at the blinking cursor. We’ll learn about what we can type here in the next sections.</p>
<h2>Becoming Familiar with Directories</h2>
<p>We’ll begin working with the terminal by typing a command. A <strong>command</strong> is an instruction that is given by a user, communicating what it is that the user wants the computer to do. You will be typing your commands into the terminal and then pressing <code>ENTER</code> or <code>RETURN</code> when you are ready for the computer to execute on a given command.</p>
<p>Let’s type the following command followed by <code>ENTER</code>. You can also copy the command.</p>
<pre><code>pwd
</code></pre>
<p>Once you run this command, you’ll receive output similar to the following:</p>
<pre><code>/home/sammy
</code></pre>
<p>The <code>pwd</code> command stands for “<strong>p</strong>resent <strong>w</strong>orking <strong>d</strong>irectory,” and it lets you know where you are within the current filesystem.</p>
<p>In this example, you are in the directory (or folder) called <code>/home/sammy</code>, which stands for the user called <code>sammy</code>. If you are logged in as <code>root</code>, a user with elevated privileges, then the directory would be called <code>/root</code>. On a personal computer, this directory may be called the name of the user who owns the computer. Sammy Shark’s computer may have <code>/sammy</code> or <code>/sammy-shark</code> or <code>/home/sammy</code> as their primary user directory.</p>
<p>Right now, this directory is empty. Let’s create a directory to store the files we’ll be creating as we go through this tutorial, which we can call files, for example.</p>
<p>To do this, we’ll use the <code>mkdir</code> command, which stands for “<strong>m</strong>ake <strong>d</strong>irectory.” After we type the command, we’ll need to write the name of the folder, which will pass the value to the command so that the command can execute on creating this directory. This value (the name of the folder) is known as an <strong>argument</strong>, which is an input being given to the command. If you are familiar with natural language grammar, you can think of the argument as an object that is being acted upon by the verb of the command.</p>
<p>In order to create a new directory called <code>files</code> we’ll write the following, with <code>mkdir</code> being the command and <code>files</code> being the argument:</p>
<pre><code>mkdir files
</code></pre>
<p>After you run this command, you won’t receive any output other than a new line with a blinking cursor. With this fresh line on your terminal, you are ready for your next command.</p>
<h2>Listing Contents and Understanding Permissions</h2>
<p>As we have not received any concrete feedback about our new directory yet, we’ll use a command to learn more about what is in our present working directory. You can confirm that the new directory is indeed there by listing out the files in the directory, with the <code>ls</code> command (signifying “<strong>l</strong>i<strong>s</strong>t”):</p>
<pre><code>ls
</code></pre>
<p>You’ll receive output that confirms the files directory is there:</p>
<pre><code>files
</code></pre>
<p>This gives us general information about what is in our present working directory. If we want to have more details, we can run the <code>ls</code> command with what is called a flag. In Linux commands, a <strong>flag</strong> is written with a hyphen <code>-</code> and letters, passing additional options (and more arguments) to the command. In our example, we’ll add the <code>-l</code> flag, which — when paired with <code>ls</code> — denotes that we would like to use the option to use a long listing format with our command.</p>
<p>Let’s type this command and flag, like so:</p>
<pre><code>ls -l
</code></pre>
<p>Upon pressing <code>ENTER</code>, we’ll receive the following output in our terminal:</p>
<pre><code>total 4
drwxr-xr-x 2 sammy sammy 4096 Nov 13 18:06 files
</code></pre>
<p>Here, there are two lines of output. The first line refers to computer memory blocks being allocated to this directory, the second line mostly refers to user permissions on the file.</p>
<p>To get a somewhat more human readable output, we can also pass the <code>-h</code> or <code>--human-readable</code> flag, which will print memory sizes in a human readable format, as below. Generally, one hyphen <code>-</code> refers to single-letter options, and two hyphens <code>--</code> refer to options that are written out in words. Note that some options can use both formats. We can build multiple options into a command by chaining flags together, as in <code>-lh</code>.</p>
<p>For example, the two commands below deliver the same results even though they are written differently:</p>
<pre><code>ls -lh
</code></pre>
<pre><code>ls -l --human-readable
</code></pre>
<p>Both of these commands will return the following output, similar to the output above but with greater context of the memory blocks:</p>
<pre><code>total 4.0K
drwxr-xr-x 2 sammy sammy 4.0K Nov 13 18:06 files
</code></pre>
<p>The first line of output lets us know that 4K of computer memory is dedicated to the folder. The second line of output has many more details, which we’ll go over in more detail. A general high-level reference of all the information that we’ll cover is indicated in the table below.</p>
<table>
<thead>
<tr>
<th>File type</th>
<th>Permissions</th>
<th>Link count</th>
<th>Owner</th>
<th>Group</th>
<th>File size</th>
<th>Last modified date</th>
<th>File name</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>rwxr-xr-x</td>
<td>2</td>
<td>sammy</td>
<td>sammy</td>
<td>4.0K</td>
<td>Nov 13 18:06</td>
<td>files</td>
</tr>
</tbody>
</table>
<p>You’ll note that the name of our directory, <code>files</code>, is at the end of the second line of output. This name indicates which specific item in the <code>/home/sammy</code> user directory is being described by the line of output. If we had another file in the directory, we would have another line of output with details on that file.</p>
<p>At the front of the line, there is a list of characters and dashes. Let’s break down the meaning of each of the characters:</p>
<table>
<thead>
<tr>
<th>Character</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td><strong>d</strong>irectory (or folder) — a type of file that can hold other files, useful for organizing a file system; if this were <code>-</code> instead, this would refer to a non-directory file</td>
</tr>
<tr>
<td>r</td>
<td><strong>r</strong>ead — permission to open and read a file, or list the contents of a directory</td>
</tr>
<tr>
<td>w</td>
<td><strong>w</strong>rite — permission to modify the content of a file; and to add, remove, rename files in a directory</td>
</tr>
<tr>
<td>x</td>
<td>e<strong>x</strong>ecute — permission to run a file that is a program, or to enter and access files within a directory</td>
</tr>
</tbody>
</table>
<p>In the first <code>drwx</code> characters of the string, the first letter <code>d</code> means that the item <code>files</code> is a directory. If this were a file other than a directory, this string of characters would begin with a hyphen instead, as in <code>-rwx</code>, where the first hyphen signifies a non-directory file. The following three letters, <code>rwx</code>, represent the permissions for the <em>owner</em> of the directory <code>files</code>, and mean that the directory <code>files</code> can be <strong>r</strong>ead, <strong>w</strong>ritten, and e<strong>x</strong>ecuted by the owner of the file. If any of these characters were replaced with hyphens, that would mean that the owner does not have the type of permission represented by that character. We’ll discuss how to identify the owner of a file in just a moment.</p>
<p>The next three characters in the output are <code>r-x</code>, which represent the <em>group</em> permissions for the <code>files</code> directory. In this instance, the group has read and execute permissions, but not write permissions, as the <code>w</code> is replaced with a <code>-</code>. We’ll discuss how to identify the group in just a moment.</p>
<p>The final three characters of the first string, <code>r-x</code> represents the permissions for any other groups that have access to the machine. In this case, these user groups can also read and execute, but not write.</p>
<p>The number <code>2</code> in the output refers to the number of links to this file. In Linux, <strong>links</strong> provide a method to create shortcuts to help users navigate the filesystem. When you created this file, Linux did some background work to create an absolute link to the file, and a self-referential link to the file to allow for users to navigate along a relative path. We’ll discuss absolute and relative paths in the next section.</p>
<p>After the number <code>2</code>, the word <code>sammy</code> is displayed twice. This part of the output gives information about the owner and group associated with the <code>files</code> directory. The first instance of <code>sammy</code> in this line refers to the owner of the directory, whose permissions we saw earlier are <code>rwx</code>. The <code>sammy</code> user is the owner as we created the <code>files</code> directory as the <code>sammy</code> user and are the current owner of the file. Though the <code>sammy</code> user is the only user in our current environment, Unix-like operating systems often have more than one user and so it is useful to know which user has ownership of a file.</p>
<p>The second instance of <code>sammy</code> refers to the group that has access to the <code>files</code> directory, whose permissions we saw earlier are <code>r-x</code>. In this case, the group name is the same as the owner username <code>sammy</code>. In real-world environments, there may be other groups on the operating system that have access to the directory, such as <code>staff</code> or a username like <code>admin</code>.</p>
<p>The rest of the details on this output line are the <code>4.0K</code> for the memory allocation of the directory on the machine, and the date that the directory was last modified (so far, we have just created it).</p>
<p>With this greater understanding of file systems and permissions, we can move onto navigating the file system on our Linux terminal.</p>
<h2>Navigating the Filesystem</h2>
<p>So far, we have learned how to determine where we are in a filesystem, how to make a new directory, how to list out files, and how to determine permissions.</p>
<p>Let’s next learn how to move around the file system. We have made a new directory, but we are still in the main <code>/home/sammy</code> user directory. In order to move into the <code>/home/sammy/files</code> directory that we have created, we’ll use the cd command and pass the name of the directory we want to move into as the argument. The command <code>cd</code> stands for “<strong>c</strong>hange <strong>d</strong>irectory,” and we’ll construct it like so:</p>
<pre><code>cd files
</code></pre>
<p>Again, you won’t receive output other than a new line with a blinking cursor, but we can check that we are in the <code>/home/sammy/files</code> directory with the <code>pwd</code> command we used earlier:</p>
<pre><code>pwd
</code></pre>
<p>You’ll get the following output, confirming where you are:</p>
<pre><code>/home/sammy/files
</code></pre>
<p>This validates that you are in the <code>/home/sammy/files</code> directory of the <code>/home/sammy</code> user directory. Does this syntax look familiar to you? It may remind you of a website’s URL with its forward slashes, and, indeed, websites are structured on servers within directories, too.</p>
<p>Let’s move to the primary directory of the server. Regardless of where we are in a filesystem, we can always use the command <code>cd /</code> to move to the primary directory:</p>
<pre><code>cd /
</code></pre>
<p>To confirm that we have moved and learn what is in this directory, let’s run our list command:</p>
<pre><code>ls 
</code></pre>
<p>We’ll receive the following output:</p>
<pre><code>bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  s  sbin  srv  sys  tmp  usr  var
</code></pre>
<p>There are a lot of files in there! The <code>/</code> directory is the main directory of a Linux server, referred to as the “root” directory. Note that the root directory is different from the default “root” user. You can think of the / directory as the major artery of a Linux machine, as it contains all the folders necessary to run the computer. For example, the sys directory holds the Linux kernel and system information virtual filesystem. If you would like to learn more about each of these directories, you can visit the <a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.html">Linux Foundation documentation</a>.</p>
<p>You’ll also notice that there is a directory we have been in already, the <code>/home</code> user folder. From the <code>/</code> directory, we can change directories back into <code>/home</code> then back into <code>files</code>, or we can move directly back into that folder by typing the absolute path there with <code>cd</code>:</p>
<pre><code>cd /home/sammy/files
</code></pre>
<p>Now, if you run <code>pwd</code> you’ll receive <code>/home/sammy/files</code> as your output.</p>
<p>A <strong>file path</strong> is the representation of where a file or directory is located on your computer or server. You can call a path to a file or directory in either a relative or absolute way. A <strong>relative path</strong> would be when we move to a location relative to our current working directory, like we did when we were already in <code>/home/sammy/</code> and then moved into <code>files/</code>. An absolute path is when we call the direct line to a location, as we did above with <code>/home/sammy/files</code>, showing that we started in the <code>/</code> directory, called the <code>/home/sammy/</code> user directory and then the nested <code>files/</code> directory.</p>
<p>Additionally, Linux leverages <strong>dot notation</strong> to help users navigate via relative paths. A single <code>.</code> stands for the directory you are currently in, and a double <code>..</code> stands for the parent directory. So, from where we currently are (<code>/home/sammy/files</code>), we can use two dots to return to the parent <code>/home/sammy</code> user directory, like so:</p>
<pre><code>cd ..
</code></pre>
<p>If you run <code>pwd</code>, you’ll receive <code>/home/sammy</code> as your output, and if you run <code>ls</code>, you’ll receive <code>files</code> as your output.</p>
<p>Another important symbol to be familiar with is <code>~</code> which stands for the home directory of your machine. Here, our home directory is called <code>/home/sammy</code> for the sammy user, but on a local machine it may be your own name as in <code>sammy-shark/</code>.</p>
<p>You can type the following from anywhere on your machine and return to this home directory:</p>
<pre><code>cd ~
</code></pre>
<p>At this point, feel free to navigate around your file system with the commands you have learned so far. In the next section, we’ll begin working with text files.</p>
<h2>Creating and Modifying Text Files</h2>
<p>Now that we have a foundation in the Linux file system and how to get around it, let’s start creating new files and learn about how to manipulate text on the command line.</p>
<p>Let’s first be sure that we’re in the <code>files/</code> directory of the <code>/home/sammy</code> user folder, which we can do by either verifying with pwd, or by changing directories on the absolute path:</p>
<pre><code>cd /home/sammy/files
</code></pre>
<p>Now, we’ll create a new text file. We’ll be making a <code>.txt</code> file, which is a standard file that can be read across operating systems. Unlike <code>.doc</code> files, a <code>.txt</code> file is composed of <em>unformatted</em> text. Unformatted text, including the text in .txt` files, can readily be used on the command line, and therefore can be used when working with textual data programmatically (as in, to automate text analysis, to pull information from text, and more).</p>
<p>We’ll begin by using the <code>touch</code> command, which can create a new file or modify an existing file. To use it, you can use the command <code>touch</code> and pass the name of the text file you want to create as the argument, as demonstrated below.</p>
<pre><code>touch ocean.txt
</code></pre>
<p>Once you press <code>ENTER</code>, you’ll receive a new line of the command prompt, and you can list the current contents of <code>files/</code> to ensure it was created.</p>
<pre><code>ls
</code></pre>
<pre><code>ocean.txt
</code></pre>
<p>So far we have created an <code>ocean.txt</code> file which contains no text at the time of creation.</p>
<p>If we want to create a text file that is initialized with text, we can use the <code>echo</code> command, which is used to display strings of text in Linux.</p>
<p>We can use <code>echo</code> directly on the command line to have the interface repeat after us. The traditional first program, <code>&quot;Hello, World&quot;</code>, can be written with <code>echo</code> like so:</p>
<pre><code>echo Hello, World
</code></pre>
<pre><code>Hello, World!
</code></pre>
<p>Named for Echo of Ovid’s <em>Metamorphosis</em>, the <code>echo</code> command returns back what we request. In this case, it echoed, “Hello, World” On its own, however, the <code>echo</code> command does not allow us to store the value of our text into a text file. In order to do that, we will need to type the following:</p>
<pre><code>echo &quot;Sammy the Shark&quot; &gt; sammy.txt
</code></pre>
<p>The above command uses echo, then the text we would like to add to our file in quotes, then the redirection operator <code>&gt;</code>, and finally the name of our new text file, <code>sammy.txt</code>.</p>
<p>We can check that our new file exists, again with <code>ls</code>.</p>
<pre><code>ls
</code></pre>
<pre><code>ocean.txt  sammy.txt
</code></pre>
<p>We now have two text files in our <code>/home/sammy/files</code> user folder. Next, we can confirm that the file <code>sammy.txt</code> does have the text we asked the terminal to echo into it. We can do that with the <code>cat</code> command. Short for con<strong>cat</strong>enate, the <code>cat</code> command is very useful for working with files. Among its functions is showing the contents of a file.</p>
<pre><code>cat sammy.txt
</code></pre>
<p>Once we run the command, we’ll receive the following output:</p>
<pre><code>Sammy the Shark
</code></pre>
<p>If we were to run <code>cat</code> on the empty file <code>ocean.txt</code>, we would receive nothing in return as there is no text in that file. We can add text to this existing file with <code>echo</code> as well. Let’s add a quote from Zora Neale Hurston to the file.</p>
<pre><code>echo &quot;Some people could look at a mud puddle and see an ocean with ships.&quot; &gt; ocean.txt
</code></pre>
<p>Now, if we run <code>cat</code> on the file, we’ll receive output of the text we just entered.</p>
<pre><code>cat ocean.txt
</code></pre>
<pre><code>Some people could look at a mud puddle and see an ocean with ships. 
</code></pre>
<p>So far, we have created text files and have added text to these files, but we have not yet modified these files. If we would like to do that, we can use a command-line text editor. Several popular choices exist, including Vim and Emacs. For our purposes, we’ll use nano, which is a less complex CLI text editor program that we can use to begin our exploration.</p>
<p>The nano text editor can be summoned with the <code>nano</code> command. If we want to edit our existing <code>sammy.txt</code> file, we can do so by passing the file name as an argument.</p>
<pre><code>nano sammy.txt
</code></pre>
<p>The file will open up on your terminal:</p>
<pre><code>Sammy the Shark
</code></pre>
<p>With your keyboard’s arrow keys, move your cursor to the end of the line and begin typing a few lines from the perspective of Sammy.</p>
<blockquote>
<p><strong>Note</strong>: On the command line, you can’t use your mouse or other pointer to navigate, both through the file system and within files. You’ll need to use your keyboard, and your arrow keys in particular, to move around textual files.</p>
</blockquote>
<p>When you’re done with your file, it may read something like this:</p>
<pre><code>Sammy the Shark

Hello, I am Sammy.
I am studying computer science.
Nice to meet you!
</code></pre>
<p>With your file now containing the text you would like, we can now save and close the file. You may notice that there is some guidance at the bottom of your terminal window:</p>
<pre><code>^G Get Help   ^O WriteOut   ^R Read File  ^Y Prev Page  ^K Cut Text   ^C Cur Pos
^X Exit       ^J Justify    ^W Where Is   ^V Next Page  ^U UnCut Text ^T To Spell
</code></pre>
<p>Because we are currently done with working on this file, we would like to Exit the file. Here, the <code>^</code> symbol refers to the <code>Control</code> or <code>CTRL</code> key on your keyboard, and the output above tells us that we need to combine that key with <code>X</code> (use this lower case, without pressing the <code>SHIFT</code> key) in order to leave the file. Let’s press those two keys together:</p>
<pre><code>CTRL x
</code></pre>
<p>The above is often written inline as <code>CTRL + X</code> or <code>Ctrl+x</code> in technical documentation.</p>
<p>At this point, you’ll receive the following prompt:</p>
<pre><code>Save modified buffer?                          
 Y Yes
 N No           ^C Cancel
</code></pre>
<p>In order to save it, we’ll press the letter <code>y</code> for yes:</p>
<pre><code>y
</code></pre>
<p>You’ll receive feedback like the following.</p>
<pre><code>File Name to Write: sammy.txt
</code></pre>
<p>There are additional options, including cancelling with <code>CTRL + C</code>, but if you are comfortable with closing the file, you can press <code>ENTER</code> at this point to save the file and exit it.</p>
<p>Let’s say that we want to make a few files of students at DigitalOcean University. Let’s create a new directory in <code>files/</code> called <code>students</code>:</p>
<pre><code>mkdir students
</code></pre>
<p>Next, let’s move <code>sammy.txt</code> into the new <code>students/</code> directory. The <code>mv</code> command, which stands for <strong>m</strong>o<strong>v</strong>e, will allow us to change the location of a file. The command is constructed by taking the file we want to move as the first argument, and the new location as the second argument. Both of the following executions will produce the same result.</p>
<pre><code>mv sammy.txt students
</code></pre>
<pre><code>mv sammy.txt students/sammy.txt
</code></pre>
<p>This latter option would be useful if we would like to change the name of the file, as in <code>mv sammy.txt students/sammy-the-shark.txt</code>.</p>
<p>Now, if we run the <code>ls</code> command, we’ll see that only <code>ocean.txt</code> and the <code>students/</code> directory are in our current directory (<code>files/</code>). Let’s move into the <code>students/</code> folder.</p>
<pre><code>cd students
</code></pre>
<p>In order to have a template for the other students, we can copy the <code>sammy.txt</code> file to create more files. To do this, we can use the <code>cp</code> command, which stands for <strong>c</strong>o<strong>p</strong>y. This command works similarly to the <code>mv</code> command, taking the original file as the first argument, and the new file as the second argument. We’ll make a file for Alex the Leafy Seadragon:</p>
<pre><code>cp sammy.txt alex.txt
</code></pre>
<p>Now, we can open alex.txt and inspect it.</p>
<pre><code>nano alex.txt
</code></pre>
<p>So far, <code>alex.txt</code> looks identical to <code>sammy.txt</code>. By replacing some of the words, we can modify this file to read like the following. Note that you can use <code>CTRL + K</code> to remove an entire line.</p>
<pre><code>Alex the Leafy Seadragon

Hello, I am Alex.
I am studying oceanography.
Nice to meet you!
</code></pre>
<p>You can save and close the file by pressing <code>CTRL + X</code> then <code>y</code> then <code>ENTER</code>.</p>
<p>If you would like to get more practice with text files, consider creating files for Jamie the Mantis Shrimp, Jesse the Octopus, Drew the Squid, or Taylor the Yellowfin Tuna.</p>
<p>Once you feel comfortable with creating, editing, copying, and moving text files, we can move onto the next section.</p>
<h2>Autocompletion and History</h2>
<p>Many versions of the command line allow you to autocomplete and to reuse commands as you go. This supports you moving more quickly as it saves you typing time.</p>
<p>Try typing <code>cat</code> along with the first few letters of one of the text files you have been working on — for example, <code>cat sa</code>. Before you finish typing the whole file name of <code>sammy.txt</code>, press the <code>TAB</code> key instead. This should autocomplete the full file name, so that your terminal prompt displays the following:</p>
<pre><code>cat sammy.txt
</code></pre>
<p>Now, if you press <code>ENTER</code>, the terminal should return the contents of the file to the command line.</p>
<p>Another shortcut is to press the <code>UP</code> arrow key, which will let you cycle through the most recent commands you have run. On a new line with a blinking cursor, press the <code>UP</code> arrow key a few times to have quick access to your previous commands.</p>
<p>If you need to replicate all the commands you have done in your terminal, you can also summon the entire history of this session with the aptly named <code>history</code> command:</p>
<pre><code>history
</code></pre>
<p>Depending on how much you have practiced, you should receive 30 or more lines of commands, starting with the following output:</p>
<pre><code>    1  pwd
    2  mkdir files
    3  ls
    4  ls -l
...
</code></pre>
<p>Familiarizing yourself with these shortcuts will support you as you become more proficient with the command line interface.</p>
<h2>Working with Files from the Web</h2>
<p>One of the most exciting aspects of working on a command line interface connected to the internet is that you have access to all of the resources on the web, and can act on them in an automated way. With the terminal, you can also directly access cloud servers that you have credentials for, manage and orchestrate cloud infrastructure, build your own web apps, and more. For now, as we have already learned how to work with text files on the terminal, we’ll go over how to pull down a text file from the web so that the machine we are using has that text file available to us.</p>
<p>Let’s move back into the <code>files/</code> directory:</p>
<pre><code>cd /home/sammy/files
</code></pre>
<p>From here, we’ll use the <code>curl</code> command to transfer data from the web to our local terminal. The command <code>curl</code> stands for <strong>c</strong>lient <strong>URL</strong> (web address).</p>
<p>We have uploaded a short passage from Jules Verne’s Twenty Thousand Leagues Under the Seas on a cloud server. We’ll pass the URL of that file to the curl command, as demonstrated below.</p>
<pre><code>curl https://assets.digitalocean.com/articles/command-line-intro/verne_twenty-thousand-leagues.txt
</code></pre>
<p>Once we press <code>ENTER</code>, we’ll receive the text of the passage as output to our terminal (excerpted below)</p>
<pre><code>&quot;You like the sea, Captain?&quot;

&quot;Yes; I love it! The sea is everything. It covers seven tenths of the terrestrial globe.
...
&quot;Captain Nemo,&quot; said I to my host, who had just thrown himself on one of the divans, &quot;this
is a library which would do honor to more than one of the continental palaces, and I am
absolutely astounded when I consider that it can follow you to the bottom of the seas.&quot;
</code></pre>
<p>While it’s interesting to have the text display on our terminal window, we do not have the file available to us, we have only transferred the data but have not stored it. (You can verify that the file is not there by running <code>ls</code>).</p>
<p>In order to save the text to a file, we’ll need to run curl with the <code>-O</code> flag, which enables us to <strong>o</strong>utput the text to a file, taking the same name of the remote file for our local copy.</p>
<pre><code>curl -O https://assets.digitalocean.com/articles/command-line-intro/verne_twenty-thousand-leagues.txt
</code></pre>
<p>You’ll receive feedback from the terminal that your file has downloaded.</p>
<pre><code>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  2671  100  2671    0     0  68487      0 --:--:-- --:--:-- --:--:-- 68487
</code></pre>
<p>If you would like to use a specific and alternate name of the file, you could do so with the <code>-o</code> flag and pass the name of the new file as an argument (in this case, <code>jules.txt</code>).</p>
<pre><code>curl -o jules.txt https://assets.digitalocean.com/articles/command-line-intro/verne_twenty-thousand-leagues.txt
</code></pre>
<p>We can now work on this file exactly as we would any other text file. Try using <code>cat</code>, or editing it with <code>nano</code>.</p>
<p>In the next section, we’ll clean up some of the files and exit our terminal.</p>
<h2>Removing Files and Terminating Commands</h2>
<p>As with any other computer, we sometimes need to remove files and folders that are no longer relevant, and exit the program we are using.</p>
<p>Let’s say that the students we know from DigitalOcean University have graduated and we need to clean up their files and the relevant folder. Ensure you are in the <code>students/</code> directory:</p>
<pre><code>cd /home/sammy/files/students
</code></pre>
<p>If you run <code>ls</code>, your folder may have a few files, like so:</p>
<pre><code>alex.txt  drew.txt  jamie.txt  jesse.txt  sammy.txt  taylor.txt
</code></pre>
<p>We can remove individual files with the <code>rm</code> command, which stands for <strong>r</strong>e<strong>m</strong>ove. We’ll need to pass the file we want to remove as the argument.</p>
<p>Warning: Note that once you remove a file, it cannot be undone. Be sure that you want to remove the file before pressing <code>ENTER</code>.</p>
<pre><code>rm sammy.txt
</code></pre>
<p>Now, if we run <code>ls</code>, we’ll notice that <code>sammy.txt</code> is no longer in the folder:</p>
<pre><code>alex.txt  drew.txt  jamie.txt  jesse.txt  taylor.txt
</code></pre>
<p>While we now know we can remove individual files with <code>rm</code>, it is not very time efficient if we want to remove the entire <code>students/</code> directory and all of its contents.</p>
<p>The command that is used to remove directories is called <code>rmdir</code>, which stands for <strong>r</strong>e<strong>m</strong>ove <strong>d</strong>irectory. Let’s move to the parent folder of files so that we can work with the <code>students/</code> directory from there (we would not be able to delete a folder we are presently in).</p>
<pre><code>cd ..
</code></pre>
<p>From the <code>/home/sammy/</code> user directory, we can run <code>rmdir</code> on students.</p>
<pre><code>rmdir students
</code></pre>
<p>However, this does not work, as we receive the following feedback:</p>
<pre><code>rmdir: failed to remove 'students': Directory not empty
</code></pre>
<p>The command did not work as rmdir only works on empty directories and the students directory still has files in it. (Here, you can create a new, empty folder, and try <code>rmdir</code> on it. Empty folders can be removed with <code>rmdir</code>.)</p>
<p>To remove the directory with files still inside, we’ll need to try a different option. In computer science, recursion is commonly used to iteratively self-reference; so we can call both a primary item and all its dependencies. Using the rm command, we can recursively remove the primary students directory and all of its content dependencies. We’ll use the <code>-r</code> flag, which stands for <strong>r</strong>ecursive, and pass the folder <code>students</code> as the argument.</p>
<pre><code>rm -r students
</code></pre>
<p>At this point, if we run <code>ls</code>, we’ll notice that <code>students/</code> is no longer in our present directory, and none of the files it held are available either, as they have all been deleted.</p>
<p>When you are done with a terminal session, and especially when you are working on a remote server, you can exit the terminal with the <code>exit</code> command. Once you feel comfortable with what you have achieved in this session (as you won’t be able to restore it), you can type the following, followed by <code>ENTER</code> to leave the terminal.</p>
<pre><code>exit
</code></pre>
<p>On our terminal, we’ll receive the following output, confirming that our session has ended.</p>
<pre><code>Session ended
</code></pre>
<p>With this session complete, you can refresh this page and then launch a new terminal to try out alternate commands, or create a new file system to explore.</p>
<h2>Conclusion</h2>
<p>Congratulations! You now know your way around the terminal interface, and are well on your way to doing more with computers and servers.</p>
<p>To continue your learning, you can take a guided pathway on setting up and managing remote servers with our Introduction to Cloud Computing curriculum.</p>
</article>
    </div>
    <footer>
  <p><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" class="logo">CC BY-NC 4.0</a> 2022</p>

  <p><a href="https://github.com/ltagliaferri/dh-rutgers-2022" target="_blank" class="logo">View code repo</a></p>

</footer>

    <script src="/dh-rutgers-2022/js/script.js"></script>
    
  </body>
</html>
